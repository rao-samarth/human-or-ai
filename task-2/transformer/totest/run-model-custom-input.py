# Generated by Claude Sonnet 4.5

import torch
from pathlib import Path
from peft import PeftModel, PeftConfig
from transformers import AutoModelForSequenceClassification, AutoTokenizer

# Configuration
MODEL_PATH = "../tier_c_final_model"
INPUT_FILE = "input.txt"

# Class labels
class_names = {
    0: 'Class 1: Human-written',
    1: 'Class 2: AI-written',
    2: 'Class 3: AI-mimicry'
}

def load_model():
    """Load the tier_c_final_model"""
    print("Loading tier_c_final_model...")
    
    config = PeftConfig.from_pretrained(MODEL_PATH)
    base_model = AutoModelForSequenceClassification.from_pretrained(
        config.base_model_name_or_path, 
        num_labels=3
    )
    tokenizer = AutoTokenizer.from_pretrained(config.base_model_name_or_path)
    model = PeftModel.from_pretrained(base_model, MODEL_PATH)
    model.eval()
    
    print("âœ“ Model loaded successfully\n")
    return model, tokenizer

def predict(text, model, tokenizer):
    """Run prediction on input text"""
    # Tokenize the input
    inputs = tokenizer(text, return_tensors="pt", truncation=True, max_length=512)
    
    # Get prediction
    with torch.no_grad():
        logits = model(**inputs).logits
        probs = torch.softmax(logits, dim=1)[0]
        predicted_class = torch.argmax(probs).item()
        confidence = probs[predicted_class].item()
    
    return predicted_class, confidence, probs

def main():
    # Read input text
    input_path = Path(INPUT_FILE)
    if not input_path.exists():
        print(f"Error: {INPUT_FILE} not found!")
        return
    
    with open(input_path, 'r', encoding='utf-8') as f:
        text = f.read().strip()
    
    if not text:
        print(f"Error: {INPUT_FILE} is empty!")
        return
    
    print(f"Input text ({len(text)} characters):")
    print("-" * 80)
    print(text)
    print("-" * 80)
    print()
    
    # Load model
    model, tokenizer = load_model()
    
    # Run prediction
    predicted_class, confidence, probs = predict(text, model, tokenizer)
    
    # Display results
    print("Results:")
    print("=" * 80)
    print(f"Predicted Class: {class_names[predicted_class]}")
    print(f"Confidence Score: {confidence}")
    print()
    print("All class probabilities:")
    for class_id, prob in enumerate(probs):
        print(f"  {class_names[class_id]}: {prob.item()}")
    print("=" * 80)

if __name__ == "__main__":
    main()
